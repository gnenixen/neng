#!/usr/bin/env python

Import( '*' )

import os;

register_file_name = "register.d";

register_file_header = """/*
    THIS FILE IS AUTOGENERATED,
    DO NOT EDIT IT,
    FOR REFS SEE modules/SCsub
*/
module engine.modules.register;

private {
    import engine.core.object;
    import engine.modules;
}

private template TRegiterStaticModule_Check( string name ) {
    import std.string;

    enum TRegiterStaticModule_Check = format(
        "
        import engine.modules.%1$s;

        static if (
            !__traits( compiles, mixin( \\"{ import engine.modules.%1$s; import engine.core.object; newObject!CMD_%1$s(); }\\" ) )
        ) {
            pragma( msg, \\"Module ( %1$s ) invalid registration, please create CMD_%1$s in modules/%1$s/package.d\\" );
        } else
        ",
        name
    );
}

private template TRegiterStaticModule( string name ) {
    import std.string : format;

    enum TRegiterStaticModule = TRegiterStaticModule_Check!name ~ format(
        "
            {
                GModules.regModule( NewObject!CMD_%1$s() );
            }
        ",
        name
    );
}
"""

exclude_mods = [
    ""
];

class CModule:
    def __init__( self ):
        subfolders = [ f.path for f in os.scandir( env.Dir( "." ).abspath ) if f.is_dir() ]
        
        reg_lines = "void modules_registerStatic() {\n";

        for i in subfolders:
            reg_lines += "\tmixin( TRegiterStaticModule!\"" + os.path.basename( i ) + "\" );\n";
        
        reg_lines += "}\n";

        file_content = register_file_header + reg_lines;
        
        reg_file = open( env.Dir( "." ).abspath + "/" + register_file_name, "w+" );
        reg_file.write( file_content );
        reg_file.close();

    def mod_src( self ):
        return env.get_source_files(
            ignore_folders = exclude_mods
        );

    def mod_build( self ):
        return env.CLibraryBR();

    def mod_sub( self ):
        return ["core", "thirdparty"];

env.reg_module( "modules", CModule() );
